# 设计模式学习笔记

---

## SOLID设计原则

### **单一责任原则**：
==一个类只负责一件事==。如果这个类做了很多事就需要拆分这个类；如果一个类的职责过多，相当于把它们耦合在了一起，那么修改一个职责的内容可能会削弱这个类完成其它职责的能力；

### **开放封闭原则**：
==类应该对扩展开放，对修改关闭。== 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。

### **里氏替换原则**：
==子类对象必须能替换掉所有父类对象。==

### **接口分离原则**：
==不应强迫client依赖于他们不使用的方法==。使用多个专门接口比使用单一的总接口更好；

### **依赖倒置原则**：
==高层模块不应依赖于低层模块，二者都应依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象==。
	细节依赖于抽象：底层模块实现抽象；
	A依赖B：先有B，A才能使用B；
#### 目的：
- **降低耦合**：通过引入抽象层，将高层模块和低层模块解耦，使得它们可以独立变化。
- **提高灵活性**：当需要更改低层模块时，只要抽象层不变，高层模块就不需要修改。
- **增强可测试性**：高层模块可以通过模拟（Mock）抽象层的实现来进行测试，而不必依赖具体的低层模块。
### **迪米特法则**
==一个类对其它类知道的越少越好==。只和直接的朋友通信。

### 合成复用原则
==尽量使用对象组合，而不是通过继承来达到复用的目的。==

#### 继承复用
优点：简单、容易实现；
缺点：破坏了封装性、耦合度高，限制灵活性；

#### 合成复用
有点：维持封装性、降低耦合度、灵活性高；
缺点：有较多的对象需要管理；

## 分类

设计模式可以根据其意图或者目的来分类：

==创建型模式==：提供创建对象的机制，增加已有代码的灵活性和可复用性；

==结构型模式==：将对象和类组装成较大结构，并同时保持结构的灵活和高效；

==行为模式==：负责对象间的沟通和职责委派；

## 典型设计模式
### 创建型模式


### 结构型模式
### 行为型模式

